<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happ 小樹屋 - 點數系統邏輯 DEMO (v2.3 最終版)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f8f9fa; color: #212529; margin: 0; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
        .container { display: grid; grid-template-columns: 1fr 2fr; gap: 20px; }
        .controls, .wallet, .data-section { background-color: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #007bff; margin-top: 0; border-bottom: 2px solid #dee2e6; padding-bottom: 10px; }
        h3 { font-size: 1.2em; color: #343a40; border-bottom: none; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; }
        button, input { width: 100%; padding: 10px; border-radius: 4px; border: 1px solid #ced4da; box-sizing: border-box; font-size: 1em; }
        button { background-color: #007bff; color: white; border: none; cursor: pointer; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover:not(:disabled) { background-color: #5a6268; }
        button.danger { background-color: #dc3545; }
        button.danger:hover:not(:disabled) { background-color: #c82333; }
        button.info { background-color: #17a2b8; }
        button.info:hover { background-color: #138496; }
        .wallet-display { display: flex; justify-content: space-around; text-align: center; }
        .wallet-item span { display: block; font-size: 2em; font-weight: bold; color: #28a745; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #dee2e6; padding: 12px; text-align: left; vertical-align: top; }
        th { background-color: #e9ecef; font-weight: 600; }
        .new-row { animation: highlight 2s ease-out; }
        @keyframes highlight { from { background-color: #fff3cd; } to { background-color: transparent; } }
        .log-container { grid-column: 1 / -1; }
        .notes { background-color: #e9ecef; padding: 15px; border-radius: 5px; font-size: 0.9em; line-height: 1.5; }
        .credit-cancel { color: #1e7e34; font-style: italic; font-weight: bold; }
        .marketing-grant { color: #17a2b8; font-weight: bold; }

        /* Philosophy Section Styles */
        .philosophy-section { margin-top: 30px; }
        .philosophy-content { line-height: 1.6; color: #333; }
        .philosophy-content h3 { color: #007bff; margin-top: 25px; margin-bottom: 15px; font-size: 1.3em; border-bottom: 2px solid #e9ecef; padding-bottom: 8px; }
        .philosophy-content h4 { color: #495057; margin-top: 20px; margin-bottom: 10px; font-size: 1.1em; }
        .philosophy-content p { margin-bottom: 15px; text-align: justify; }
        .philosophy-content ul, .philosophy-content ol { margin-bottom: 15px; padding-left: 25px; }
        .philosophy-content li { margin-bottom: 8px; }
        .analogy-box, .practice-box, .closing-box { background-color: #f8f9fa; border-left: 4px solid #007bff; padding: 20px; margin: 20px 0; border-radius: 0 8px 8px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .analogy-box h4, .practice-box h4, .closing-box h4 { color: #007bff; margin-top: 0; font-weight: 600; }
        .philosophy-content strong { color: #dc3545; font-weight: 600; }
    </style>
</head>
<body>

    <h1>Happ 小樹屋 - 點數系統邏輯互動 DEMO (v2.3 最終版)</h1>
    <div class="notes">
        <p><b>v2.3 Bugfix：</b>修正了在擁有多個贈點來源時，消費扣款優先級計算錯誤的嚴重 Bug。現在系統會嚴格遵循「所有贈點 > 所有信託點數」的原則進行消耗。</p>
    </div>

    <div class="container">
        <div class="left-panel">
            <div class="controls">
                <h2>控制面板</h2>
                <div class="control-group">
                    <label>1. 儲值點數方案</label>
                    <button id="btn-purchase-a">儲值 A ($1500 送 500贈點)</button>
                    <button id="btn-purchase-b" style="margin-top:5px;">儲值 B ($500 送 100贈點)</button>
                </div>
                <hr>
                <div class="control-group">
                    <label>2. 模擬消費</label>
                    <input type="number" id="spend-amount" placeholder="輸入要消費的點數" value="1000">
                    <button id="btn-spend" class="secondary" style="margin-top:5px;">執行消費</button>
                </div>
                 <hr>
                <div class="control-group">
                    <label>3. 行銷活動</label>
                    <button id="btn-grant-referral" class="info">好友推薦 (贈 100 點)</button>
                    <button id="btn-grant-event" class="info" style="margin-top:5px;">節日活動 (贈 88 點)</button>
                </div>
                <hr>
                <div class="control-group">
                    <label>4. 申請退款</label>
                    <button id="btn-account-refund" class="danger">查詢並退款所有可退金額</button>
                </div>
            </div>
            <div class="wallet">
                <h2>使用者錢包 (User Wallet)</h2>
                <div class="wallet-display">
                    <div class="wallet-item"><h3>信託點數</h3><span id="wallet-trusted">0.00</span></div>
                    <div class="wallet-item"><h3>贈與點數</h3><span id="wallet-bonus">0.00</span></div>
                </div>
            </div>
             <div class="data-section">
                <h2>消費歷史 (Spend History)</h2>
                <table id="table-spends">
                    <thead><tr><th>消費ID</th><th>消費總額</th><th>狀態</th><th>操作</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="right-panel">
            <div class="data-section">
                <h2>儲值歷史 (Point Purchases)</h2>
                <table id="table-purchases">
                    <thead><tr><th>訂單ID</th><th>支付金額</th><th>獲得信託點</th><th>獲得贈點</th><th>狀態</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div class="log-container">
         <div class="data-section">
            <h2>點數帳本 (Point Ledger)</h2>
            <table id="table-ledger">
                <thead><tr><th>帳本ID</th><th>關聯訂單/來源</th><th>交易組ID</th><th>點數類型</th><th>交易類型</th><th>異動</th><th>交易後餘額</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    let state = {
        userWallet: { trusted_points: 0, bonus_points: 0 },
        pointPurchases: [],
        pointLedger: [],
        spendHistory: [],
    };
    const purchasePlans = {
        'A': { id: 'A', price: 1500, trusted: 1500, bonus: 500 },
        'B': { id: 'B', price: 500, trusted: 500, bonus: 100 },
    };
    let nextPurchaseId = 1, nextLedgerId = 1, nextSpendId = 1;

    function purchasePoints(planKey) {
        const plan = purchasePlans[planKey];
        const now = new Date();
        const purchase = { id: `P-${nextPurchaseId++}`, price: plan.price, trusted_received: plan.trusted, bonus_received: plan.bonus, status: 'COMPLETED', timestamp: now, newlyAdded: true };
        state.pointPurchases.push(purchase);
        state.userWallet.trusted_points += plan.trusted;
        state.userWallet.bonus_points += plan.bonus;
        state.pointLedger.push({ id: `L-${nextLedgerId++}`, purchase_id: purchase.id, source_id: purchase.id, point_type: 'TRUSTED', transaction_type: 'PURCHASE_CREDIT', amount: plan.trusted, balance_after: state.userWallet.trusted_points, timestamp: now, newlyAdded: true, transaction_group_id: null });
        state.pointLedger.push({ id: `L-${nextLedgerId++}`, purchase_id: purchase.id, source_id: purchase.id, point_type: 'BONUS', transaction_type: 'PURCHASE_CREDIT', amount: plan.bonus, balance_after: state.userWallet.bonus_points, timestamp: now, newlyAdded: true, transaction_group_id: null });
        render();
    }
    
    function grantMarketingBonus(amount, reason) {
        const now = new Date();
        const ledgerId = `L-${nextLedgerId++}`;
        state.userWallet.bonus_points += amount;
        state.pointLedger.push({
            id: ledgerId, purchase_id: null, source_id: ledgerId,
            point_type: 'BONUS', transaction_type: 'ADMIN_GRANT_CREDIT',
            amount: amount, balance_after: state.userWallet.bonus_points,
            timestamp: now, newlyAdded: true, transaction_group_id: null, notes: reason
        });
        render();
    }

    // *** REFACTORED AND BUGFIXED spendPoints function ***
    function spendPoints(amountToSpend) {
        if (amountToSpend <= 0) { alert("消費金額需大於 0"); return; }
        const totalPoints = state.userWallet.trusted_points + state.userWallet.bonus_points;
        if (amountToSpend > totalPoints) { alert(`點數不足！目前總點數: ${totalPoints}, 試圖消費: ${amountToSpend}`); return; }

        const spendId = `S-${nextSpendId++}`;
        let remainingToSpend = amountToSpend;
        const now = new Date();
        state.spendHistory.push({ id: spendId, amount: amountToSpend, timestamp: now, status: 'COMPLETED', newlyAdded: true });

        // Step 1: Accurately calculate the current balance of each individual point source.
        const sourceBalances = new Map();
        state.pointLedger.forEach(l => {
            const sourceOriginId = l.purchase_id || l.source_id; 
            if (!sourceOriginId) return;
            
            // The unique identifier for a source is its origin AND its type.
            const sourceKey = `${sourceOriginId}-${l.point_type}`;

            if (!sourceBalances.has(sourceKey)) {
                sourceBalances.set(sourceKey, {
                    balance: 0,
                    point_type: l.point_type,
                    purchase_id: l.purchase_id,
                    source_id: sourceOriginId,
                    timestamp: l.timestamp 
                });
            }
            const source = sourceBalances.get(sourceKey);
            source.balance += l.amount;
        });

        // Step 2: Create a sorted list of sources to consume from.
        const sourcesToConsume = Array.from(sourceBalances.values())
            .filter(s => s.balance > 0)
            .sort((a, b) => {
                if (a.point_type === 'BONUS' && b.point_type === 'TRUSTED') return -1;
                if (a.point_type === 'TRUSTED' && b.point_type === 'BONUS') return 1;
                return a.timestamp - b.timestamp;
            });
        
        // Step 3: Consume points from the sorted list.
        for (const source of sourcesToConsume) {
            if (remainingToSpend === 0) break;
            
            const amountConsumed = Math.min(remainingToSpend, source.balance);
            const walletKey = `${source.point_type.toLowerCase()}_points`;
            
            state.userWallet[walletKey] -= amountConsumed;
            
            state.pointLedger.push({
                id: `L-${nextLedgerId++}`,
                purchase_id: source.purchase_id,
                source_id: source.source_id,
                point_type: source.point_type,
                transaction_type: 'BOOKING_DEBIT',
                amount: -amountConsumed,
                balance_after: state.userWallet[walletKey],
                timestamp: now,
                newlyAdded: true,
                transaction_group_id: spendId
            });
            remainingToSpend -= amountConsumed;
        }
        render();
    }
    
    function cancelSpend(spendId) {
        const spendToCancel = state.spendHistory.find(s => s.id === spendId);
        if (spendToCancel.status === 'CANCELED') { alert("此筆消費已取消，無法重複操作。"); return; }
        const now = new Date();
        const debitEntriesToReverse = state.pointLedger.filter(l => l.transaction_group_id === spendId && l.transaction_type === 'BOOKING_DEBIT');
        debitEntriesToReverse.forEach(debit => {
            const walletKey = `${debit.point_type.toLowerCase()}_points`;
            const creditAmount = Math.abs(debit.amount);
            state.userWallet[walletKey] += creditAmount;
            state.pointLedger.push({
                id: `L-${nextLedgerId++}`, purchase_id: debit.purchase_id, source_id: debit.source_id,
                point_type: debit.point_type, transaction_type: 'CANCELLATION_CREDIT',
                amount: creditAmount, balance_after: state.userWallet[walletKey],
                timestamp: now, newlyAdded: true, transaction_group_id: spendId
            });
        });
        spendToCancel.status = 'CANCELED';
        alert(`消費 ${spendId} 已成功取消！`);
        render();
    }

    function calculateRefund(purchaseId) {
        const purchase = state.pointPurchases.find(p => p.id === purchaseId);
        if (!purchase) return { refundAmount: 0 };
        const transactions = state.pointLedger.filter(l => l.purchase_id === purchase.id && l.transaction_type !== 'PURCHASE_CREDIT');
        const netConsumedBonus = transactions.filter(l => l.point_type === 'BONUS').reduce((sum, l) => sum + l.amount, 0);
        const netConsumedTrusted = transactions.filter(l => l.point_type === 'TRUSTED').reduce((sum, l) => sum + l.amount, 0);
        const totalDeduction = Math.abs(netConsumedBonus) + Math.abs(netConsumedTrusted);
        const refundAmount = Math.max(0, purchase.price - totalDeduction);
        return { purchase, refundAmount };
    }

    function executeRefund(purchaseId, refundAmount, isBatch = false) {
        const purchase = state.pointPurchases.find(p => p.id === purchaseId);
        const now = new Date();
        const remainingTrusted = purchase.trusted_received + state.pointLedger.filter(l => l.purchase_id === purchase.id && l.point_type === 'TRUSTED' && l.transaction_type !== 'PURCHASE_CREDIT').reduce((sum, l) => sum + l.amount, 0);
        const remainingBonus = purchase.bonus_received + state.pointLedger.filter(l => l.purchase_id === purchase.id && l.point_type === 'BONUS' && l.transaction_type !== 'PURCHASE_CREDIT').reduce((sum, l) => sum + l.amount, 0);
        if (remainingTrusted > 0) {
             state.userWallet.trusted_points -= remainingTrusted;
             state.pointLedger.push({ id: `L-${nextLedgerId++}`, purchase_id: purchase.id, source_id: purchase.id, point_type: 'TRUSTED', transaction_type: 'REFUND_DEBIT', amount: -remainingTrusted, balance_after: state.userWallet.trusted_points, timestamp: now, newlyAdded: true, transaction_group_id: null });
        }
        if (remainingBonus > 0) {
             state.userWallet.bonus_points -= remainingBonus;
             state.pointLedger.push({ id: `L-${nextLedgerId++}`, purchase_id: purchase.id, source_id: purchase.id, point_type: 'BONUS', transaction_type: 'CLAWBACK_DEBIT', amount: -remainingBonus, balance_after: state.userWallet.bonus_points, timestamp: now, newlyAdded: true, transaction_group_id: null });
        }
        purchase.status = 'REFUNDED';
        if (!isBatch) { alert(`退款 $${refundAmount.toFixed(2)} 已成功處理！`); render(); }
    }

    function handleAccountRefund() {
        const refundablePurchases = state.pointPurchases.filter(p => p.status === 'COMPLETED');
        if (refundablePurchases.length === 0) { alert("帳戶中沒有可供退款的儲值訂單。"); return; }
        let totalRefundableAmount = 0;
        let refundBreakdown = [];
        refundablePurchases.forEach(purchase => {
            const { refundAmount } = calculateRefund(purchase.id);
            if (refundAmount > 0) {
                totalRefundableAmount += refundAmount;
                refundBreakdown.push({ purchaseId: purchase.id, amount: refundAmount });
            }
        });
        if (totalRefundableAmount === 0) { alert("經計算，您的帳戶目前沒有可退款的餘額。"); return; }
        let confirmationMessage = `系統已掃描您的所有儲值歷史。\n\n` + `總可退款金額為: $${totalRefundableAmount.toFixed(2)}\n\n` + `--- 退款明細 ---\n`;
        refundBreakdown.forEach(item => { confirmationMessage += `  - 訂單 ${item.purchaseId}: 可退 $${item.amount.toFixed(2)}\n`; });
        confirmationMessage += `\n確定要執行以上所有退款嗎？`;
        if (window.confirm(confirmationMessage)) {
            refundBreakdown.forEach(item => { executeRefund(item.purchaseId, item.amount, true); });
            alert(`帳戶退款總計 $${totalRefundableAmount.toFixed(2)} 已全部處理完畢！`);
            render();
        }
    }

    function render() {
        document.getElementById('wallet-trusted').textContent = state.userWallet.trusted_points.toFixed(2);
        document.getElementById('wallet-bonus').textContent = state.userWallet.bonus_points.toFixed(2);
        const purchasesBody = document.getElementById('table-purchases').getElementsByTagName('tbody')[0];
        purchasesBody.innerHTML = '';
        [...state.pointPurchases].reverse().forEach(p => {
            const row = purchasesBody.insertRow();
            if (p.newlyAdded) row.classList.add('new-row');
            row.innerHTML = `<td>${p.id}</td><td>$${p.price.toFixed(2)}</td><td>${p.trusted_received.toFixed(2)}</td><td>${p.bonus_received.toFixed(2)}</td><td>${p.status}</td>`;
        });
        const spendsBody = document.getElementById('table-spends').getElementsByTagName('tbody')[0];
        spendsBody.innerHTML = '';
        [...state.spendHistory].reverse().forEach(s => {
            const row = spendsBody.insertRow();
            if (s.newlyAdded) row.classList.add('new-row');
            const isCanceled = s.status === 'CANCELED';
            row.innerHTML = `<td>${s.id}</td><td>${s.amount.toFixed(2)}</td><td>${isCanceled ? '已取消' : '已完成'}</td><td><button class="secondary cancel-btn" data-spend-id="${s.id}" ${isCanceled ? 'disabled' : ''}>${isCanceled ? '已取消' : '取消'}</button></td>`;
        });
        document.querySelectorAll('.cancel-btn').forEach(btn => {
            btn.addEventListener('click', (e) => { cancelSpend(e.target.dataset.spendId); });
        });
        const ledgerBody = document.getElementById('table-ledger').getElementsByTagName('tbody')[0];
        ledgerBody.innerHTML = '';
        [...state.pointLedger].reverse().forEach(l => {
            const row = ledgerBody.insertRow();
            if (l.newlyAdded) row.classList.add('new-row');
            let amountHtml;
            if (l.transaction_type === 'CANCELLATION_CREDIT') {
                amountHtml = `<td class="credit-cancel">+${l.amount.toFixed(2)}</td>`;
            } else if (l.transaction_type === 'ADMIN_GRANT_CREDIT') {
                 amountHtml = `<td class="marketing-grant">+${l.amount.toFixed(2)}</td>`;
            } else {
                const style = l.amount > 0 ? 'color:green; font-weight:bold;' : 'color:red;';
                amountHtml = `<td style="${style}">${l.amount > 0 ? '+' : ''}${l.amount.toFixed(2)}</td>`;
            }
            const sourceDisplay = l.purchase_id || `${l.source_id} (行銷)`;
            row.innerHTML = `<td>${l.id}</td><td>${sourceDisplay}</td><td>${l.transaction_group_id || 'N/A'}</td><td>${l.point_type}</td><td>${l.transaction_type}</td>${amountHtml}<td>${l.balance_after.toFixed(2)}</td>`;
        });
        state.pointPurchases.forEach(p => p.newlyAdded = false);
        state.pointLedger.forEach(l => l.newlyAdded = false);
        state.spendHistory.forEach(s => s.newlyAdded = false);
    }

    document.getElementById('btn-purchase-a').addEventListener('click', () => purchasePoints('A'));
    document.getElementById('btn-purchase-b').addEventListener('click', () => purchasePoints('B'));
    document.getElementById('btn-spend').addEventListener('click', () => {
        const amount = parseFloat(document.getElementById('spend-amount').value);
        spendPoints(amount);
    });
    document.getElementById('btn-account-refund').addEventListener('click', handleAccountRefund);
    document.getElementById('btn-grant-referral').addEventListener('click', () => grantMarketingBonus(100, '好友推薦'));
    document.getElementById('btn-grant-event').addEventListener('click', () => grantMarketingBonus(88, '節日活動'));

    render();
});
</script>

<div class="philosophy-section">
    <div class="data-section">
        <h2>核心設計哲學：我們的點數與退款邏輯</h2>
        <div class="philosophy-content">
            <h3>1. 原則：「儲值贈點」是有條件的饋贈</h3>
            <p>我們系統的基石是一個簡單而公平的原則：「儲值贈點」是一種「有條件的饋贈」，而非「無條件的禮物」。</p>
            <p>它的存在，是為了獎勵並留住持續消費的顧客，而不是為了讓顧客在終止交易（退款）時，還能保留因該交易而產生的額外利益。</p>
            <h3>2. 類比：「滿額贈」的百貨公司邏輯</h3>
            <p>這個原則最好用一個您我都很熟悉的實體店例子來理解：</p>
            <div class="analogy-box">
                <h4>情境：百貨公司週年慶</h4>
                <ul>
                    <li>活動是「單筆消費滿 $1500，即贈送價值 $500 的旅行組合」。</li>
                    <li>您買了一組 $1500 的精華液（相當於 儲值單 A）。</li>
                    <li>您獲贈了一組價值 $500 的旅行組合（相當於 500 儲值贈點）。</li>
                    <li>回家後，您把那組 $500 的旅行組合用掉了（相當於 花掉了贈點）。</li>
                    <li>幾天後，您覺得精華液不適合，回去要求退貨（相當於 申請退款）。</li>
                </ul>
                <h4>專櫃的處理方式：</h4>
                <p>專櫃會告訴您：「精華液 $1500 可以退。但由於您已將價值 $500 的贈品使用完畢，我們需要從您的退款中扣除贈品的費用。」</p>
                <p><strong>最終您能拿回的現金是：$1500 - $500 = $1000。</strong></p>
                <p>我們的點數系統，正是基於這個公平且廣為接受的商業邏輯。</p>
            </div>
            <h3>3. 實踐：對使用者最有利的「全域點數池 FIFO」消耗原則</h3>
            <p>為了給予使用者最佳的體驗，我們在「消費」時採用了最大方的規則：</p>
            <div class="practice-box">
                <h4>核心邏輯：</h4>
                <p>「贈點」和「信託點數」分別被視為兩個獨立的全域大池子。</p>
                <h4>消耗順序：</h4>
                <ol>
                    <li>永遠優先消耗所有贈點 (按儲值順序 A→B，**行銷贈點**比儲值贈點更優先)。</li>
                    <li>所有贈點用完後，才開始消耗所有信託點數 (按儲值順序 A→B)。</li>
                </ol>
                <p>這能確保使用者永遠先花掉公司送的點數，最後才動到自己付費購買的點數，讓每一次消費都感受到最大的價值。</p>
            </div>
            <h3>4. 閉環：公平的商業模式</h3>
            <p>使用者友善的消耗規則，對應了一個嚴謹的退款審計機制。當使用者申請退款時，系統就像那位專櫃人員，會精確地回溯：</p>
            <div class="closing-box">
                <p>任何一筆退款，都會優先將使用者「已享受的**儲值贈點**價值」進行追討。而獨立的**行銷贈點**因為與儲值無關，其消耗**不會**影響退款。</p>
                <p>這並不是漏洞，而是一個刻意設計的、公平的商業閉環。它確保了贈點「鼓勵消費、提高忠誠度」的初衷得以實現，同時也保護了公司不會在使用者終止交易時，還產生額外的虧損，從而讓整個商業模式得以永續經營。</p>
            </div>
        </div>
    </div>
</div>

</body>
</html>